
============================================================
INICIANDO SISTEMA DE ANALISIS ALGORITMICO
============================================================

--- 1. Anßlisis Estructural (ANTLR) ---

--- 2. Cßlculo de Costos (Visitor) ---
Analizando: Fibonacci
DEBUG: Recursion detected: Fibonacci(n - 1)
DEBUG: Recursion detected: Fibonacci(n - 2)
Ecuacion detectada: T(n) = Max(2, T(n - 2) + T(n - 1) + 1) + 3

--- DETECTOR DEL TEOREMA MAESTRO ---
Tipo: characteristic_equation
 > MÚtodo: Ecuaci¾n CaracterÝstica
 > Polinomio: r**2 - r - 1 = 0
 > RaÝces: 1/2 - sqrt(5)/2, 1/2 + sqrt(5)/2
 > RaÝz Dominante: 1/2 + sqrt(5)/2
------------------------------------

--- DETALLE DE COSTOS ---
LÝnea    | Costo
----------------------------------------
3        | Max(2, T(n - 2) + T(n - 1) + 1) + 3
5        | 2
9        | T(n - 2) + T(n - 1) + 1
============================================================

--- 3. Validaci¾n Te¾rica (LLM) ---
Okay, evaluemos el pseudoc¾digo proporcionado para la funci¾n `Fibonacci(n)`.

**1. Identificaci¾n: Iterativo o Recursivo**

El c¾digo utiliza la funci¾n `Fibonacci` dentro de su propia definici¾n, especÝficamente llamßndose a sÝ misma con los argumentos `n-1` y `n-2`.  Por lo tanto, este algoritmo es **Recursivo**.

**2. MÚtodo Te¾rico Aplicable (Recursivo)**

Dado que se trata de una funci¾n recursiva, debemos determinar quÚ mÚtodo te¾rico es mßs adecuado para analizar su complejidad. Tenemos tres opciones principales:

*   **Teorema Maestro:** No es directamente aplicable aquÝ. El Teorema Maestro estß dise±ado para relaciones de recurrencia de la forma  `T(n) = aT(n/b) + f(n)`.  Nuestra relaci¾n de recurrencia es  `T(n) = T(n-1) + T(n-2) + O(1)`, que no encaja en ese formato. El hecho de que restemos una constante a *n* en cada llamada recursiva, en lugar de dividirlo por una constante, tambiÚn es una se±al de que el Teorema Maestro no es apropiado.

*   **Teorema de la Funci¾n CaracterÝstica (o Ecuaci¾n CaracterÝstica):**  Este es el mÚtodo mßs adecuado para analizar la recurrencia `T(n) = T(n-1) + T(n-2) + O(1)`.  Ignoramos el `O(1)` (el coste de la suma)  para resolver la parte homogenea.

*   **MÚtodo del ┴rbol de Recursi¾n:** TambiÚn podrÝa usarse, pero se vuelve engorroso rßpidamente para esta funci¾n debido a las dos llamadas recursivas.  Es ·til para *visualizar* el trabajo duplicado, pero no es la forma mßs precisa de derivar la complejidad asint¾tica.

**Aplicaci¾n del Teorema de la Funci¾n CaracterÝstica:**

1.  **Establecer la relaci¾n de recurrencia:** `T(n) = T(n-1) + T(n-2) + c` (donde `c` es una constante que representa el costo de la suma y la comparaci¾n). Para encontrar la complejidad asint¾tica, ignoraremos la constante c y nos centraremos en la parte homogenea: `T(n) = T(n-1) + T(n-2)`.

2.  **Formular la ecuaci¾n caracterÝstica:** Reemplazamos `T(n)` con `x^n`, `T(n-1)` con `x^(n-1)`, y `T(n-2)` con `x^(n-2)`.  Esto nos da:

    `x^n = x^(n-1) + x^(n-2)`

    Dividimos toda la ecuaci¾n por  `x^(n-2)`:

    `x^2 = x + 1`

    `x^2 - x - 1 = 0`

3.  **Resolver la ecuaci¾n cuadrßtica:**  Usamos la f¾rmula cuadrßtica para encontrar las raÝces:

    `x = (1 ▒ ?(1 + 4)) / 2`

    `x = (1 ▒ ?5) / 2`

    Tenemos dos raÝces:  `x1 = (1 + ?5) / 2  ? 1.618` (el n·mero ßureo, ?) y  `x2 = (1 - ?5) / 2 ? -0.618`.

4.  **Escribir la soluci¾n general:**  La soluci¾n general de la relaci¾n de recurrencia es de la forma:

    `T(n) = A * x1^n + B * x2^n`  donde A y B son constantes.

    `T(n) = A * ((1 + ?5) / 2)^n + B * ((1 - ?5) / 2)^n`

5.  **Determinar la complejidad asint¾tica:**  Dado que `|(1 + ?5) / 2| > |(1 - ?5) / 2|`, el tÚrmino `((1 + ?5) / 2)^n` domina a medida que `n` crece. Por lo tanto, la complejidad asint¾tica estß dominada por:

    `T(n) = O(((1 + ?5) / 2)^n) = O(?^n)`

    Donde ? es el n·mero ßureo.

**3. Conclusi¾n Final: Complejidad**

*   **Peor Caso (O): O(?<sup>n</sup>)** donde ? es el n·mero ßureo (aproximadamente 1.618).  Esto es exponencial.
*   **Mejor Caso (?): ?(1)** Esto ocurre cuando `n <= 1`.
*   **Promedio (?): ?(?<sup>n</sup>)**  En promedio, se comportarß como el peor de los casos ya que siempre seguirß la rama recursiva cuando `n > 1`.

**Justificaci¾n Adicional y Advertencias:**

*   **Complejidad Exponencial:** La complejidad exponencial es el principal problema con esta implementaci¾n recursiva.  Significa que el tiempo de ejecuci¾n crece extremadamente rßpido con el tama±o de la entrada.  Incluso para valores moderadamente peque±os de `n`, el cßlculo se vuelve prohibitivamente caro.

*   **Trabajo Duplicado:**  El principal problema que causa la complejidad exponencial es el *trabajo duplicado*.  Por ejemplo, para calcular `Fibonacci(5)`, calcularß `Fibonacci(4)` y `Fibonacci(3)`.  Pero `Fibonacci(4)` a su vez calcularß `Fibonacci(3)` y `Fibonacci(2)`.  `Fibonacci(3)` se calcula m·ltiples veces, y asÝ sucesivamente.  Esto conduce a un crecimiento exponencial del n·mero de llamadas a funciones.

*   **Alternativas:**  Para calcular los n·meros de Fibonacci de manera eficiente, se deben usar enfoques iterativos (con programaci¾n dinßmica o memorizaci¾n) que tengan una complejidad de tiempo lineal O(n) y una complejidad de espacio que puede ser O(1) con un enfoque iterativo con solo 2 variables, o O(n) con memorizaci¾n.

**Calificaci¾n:**

Basado en el anßlisis, incluyendo la identificaci¾n de la recursi¾n, la selecci¾n del mÚtodo te¾rico apropiado (Teorema de la Funci¾n CaracterÝstica), la aplicaci¾n correcta del teorema y la determinaci¾n precisa de la complejidad, este proyecto demuestra una buena comprensi¾n de los conceptos involucrados. Sin embargo, el proyecto podrÝa mejorarse mencionando explÝcitamente el problema del trabajo duplicado y la existencia de algoritmos iterativos mucho mßs eficientes.

--- 4. Generando Trace Table ---

Anßlisis finalizado.
