
============================================================
INICIANDO SISTEMA DE ANALISIS ALGORITMICO
============================================================

--- 1. Anßlisis Estructural (ANTLR) ---

--- 2. Cßlculo de Costos (Visitor) ---
Analizando: Fibonacci
Ecuacion detectada: T(n) = Max(2, T(2) + 1) + 3

--- DETALLE DE COSTOS ---
LÝnea    | Costo
----------------------------------------
3        | Max(2, T(2) + 1) + 3
5        | 2
9        | T(2) + 1
============================================================

--- 3. Validaci¾n Te¾rica (LLM) ---
Bien, analicemos el pseudoc¾digo proporcionado para la funci¾n Fibonacci.

**1. Identificaci¾n: Iterativo o Recursivo**

El c¾digo `Fibonacci(n)` se llama a sÝ mismo con argumentos `n-1` y `n-2`.  Por lo tanto, es un algoritmo **recursivo**.

**2. MÚtodo Te¾rico para Recursi¾n**

Para analizar la complejidad de este algoritmo recursivo, podemos considerar varios mÚtodos. Dada la estructura de la recursi¾n (dos llamadas recursivas), el **Teorema del Maestro** *no* es directamente aplicable, ya que el teorema del maestro tiene un formato especifico T(n) = aT(n/b) + f(n) y este caso no se puede reescribir facilmente a esa forma.  El **mÚtodo caracterÝstico** es el mßs adecuado en este caso porque la funci¾n recursiva se divide en dos subproblemas de tama±o `n-1` y `n-2`, generando una relaci¾n de recurrencia que puede ser resuelta con el mÚtodo caracterÝstico.  TambiÚn se podrÝa usar el **mÚtodo del ßrbol de recursi¾n**, aunque para Fibonacci se vuelve rßpidamente engorroso, pero ·til para visualizar la expansi¾n de las llamadas recursivas.

**3. Anßlisis con el MÚtodo CaracterÝstico**

La relaci¾n de recurrencia para este algoritmo es:

*   T(n) = T(n-1) + T(n-2) + O(1)  (La suma de los resultados recursivos y la operaci¾n de suma en sÝ misma)
*   T(0) = O(1)
*   T(1) = O(1)

Para simplificar el anßlisis y centrarnos en el crecimiento dominante, podemos omitir el O(1) aditivo, lo que no afectarß significativamente la complejidad asint¾tica.  Entonces trabajaremos con:

T(n) = T(n-1) + T(n-2)

La ecuaci¾n caracterÝstica asociada es:

r<sup>2</sup> - r - 1 = 0

Resolviendo esta ecuaci¾n cuadrßtica, obtenemos las raÝces:

r<sub>1</sub> = (1 + ?5) / 2  (N·mero ßureo, ? ? 1.618)
r<sub>2</sub> = (1 - ?5) / 2  (? -0.618)

Por lo tanto, la soluci¾n general para la relaci¾n de recurrencia es:

T(n) = c<sub>1</sub> * ((1 + ?5) / 2)<sup>n</sup> + c<sub>2</sub> * ((1 - ?5) / 2)<sup>n</sup>

Dado que (1 + ?5) / 2 > 1 y (1 - ?5) / 2 < 1, el tÚrmino  ((1 + ?5) / 2)<sup>n</sup>  domina el crecimiento de T(n) a medida que n aumenta. Por lo tanto,  T(n) es O(((1 + ?5) / 2)<sup>n</sup>), que es O(?<sup>n</sup>) donde ? es el n·mero ßureo.  Esto significa que la complejidad crece exponencialmente.

**4. Conclusi¾n Final: Complejidad**

*   **Peor Caso (O): O(?<sup>n</sup>)** donde ? ? 1.618 (el n·mero ßureo).  El peor caso ocurre porque el algoritmo siempre realiza todas las llamadas recursivas hasta llegar a los casos base (n <= 1).
*   **Mejor Caso (?): ?(?<sup>n</sup>)**  Aunque pueda parecer extra±o, la complejidad en el mejor caso es la misma que en el peor caso.  Esto se debe a que, incluso si la entrada es peque±a (pero mayor que 1), el algoritmo *siempre* realizarß las dos llamadas recursivas.  No hay un camino de ejecuci¾n "mßs rßpido" posible para un `n` dado.
*   **Promedio (?): ?(?<sup>n</sup>)** La complejidad promedio es tambiÚn ?(?<sup>n</sup>) por la misma raz¾n que el mejor y peor caso son iguales:  la estructura del algoritmo *siempre* obliga a la expansi¾n recursiva completa, independientemente del valor de `n` (siempre que `n > 1`).

**En Resumen:**

La implementaci¾n recursiva de Fibonacci tiene una complejidad exponencial.  Es extremadamente ineficiente para valores grandes de `n`.  SerÝa mucho mßs eficiente implementar Fibonacci de forma iterativa utilizando programaci¾n dinßmica o un simple bucle.  La complejidad iterativa serÝa O(n).

--- 4. Generando Trace Table ---

Anßlisis finalizado.
