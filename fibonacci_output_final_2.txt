
============================================================
INICIANDO SISTEMA DE ANALISIS ALGORITMICO
============================================================

--- 1. Anßlisis Estructural (ANTLR) ---

--- 2. Cßlculo de Costos (Visitor) ---
Analizando: Fibonacci
DEBUG: Recursion detected: Fibonacci(n - 1)
DEBUG: Recursion detected: Fibonacci(n - 2)
Ecuacion detectada: T(n) = Max(2, T(n - 2) + T(n - 1) + 1) + 3

--- DETECTOR DEL TEOREMA MAESTRO ---
Tipo: linear_recurrence
 > Subtipo: exponential
 > a = 2
------------------------------------

--- DETALLE DE COSTOS ---
LÝnea    | Costo
----------------------------------------
3        | Max(2, T(n - 2) + T(n - 1) + 1) + 3
5        | 2
9        | T(n - 2) + T(n - 1) + 1
============================================================

--- 3. Validaci¾n Te¾rica (LLM) ---
íExcelente! Analicemos el pseudoc¾digo proporcionado del cßlculo del Fibonacci.

**1. Identificaci¾n: Iterativo o Recursivo**

El c¾digo claramente utiliza una funci¾n que se llama a sÝ misma (`Fibonacci(n-1)` y `Fibonacci(n-2)`).  Por lo tanto, es un algoritmo **Recursivo**.

**2. MÚtodo Te¾rico para Recursi¾n**

Dado que la funci¾n recursiva se llama a sÝ misma m·ltiples veces con diferentes entradas (dos veces en este caso), y  la estructura de la recursi¾n es bastante sencilla, el mÚtodo mßs adecuado para analizar su complejidad es el **MÚtodo del ┴rbol de Recursi¾n**.  Si intentßramos aplicar el Teorema Maestro, tendrÝamos una ecuaci¾n de recurrencia de la forma T(n) = T(n-1) + T(n-2) + O(1), que no se ajusta a la forma requerida para el Teorema Maestro (T(n) = aT(n/b) + f(n)). El mÚtodo caracterÝstico podrÝa usarse para *resolver* la recurrencia, pero no para *analizar* su complejidad directamente desde el c¾digo. El ßrbol de recursi¾n visualiza c¾mo el problema se descompone.

**3. Anßlisis con el ┴rbol de Recursi¾n**

*   **RaÝz:** `Fibonacci(n)`
*   **Nivel 1:** `Fibonacci(n-1)` + `Fibonacci(n-2)`
*   **Nivel 2:** `Fibonacci(n-2)` + `Fibonacci(n-3)` + `Fibonacci(n-3)` + `Fibonacci(n-4)`
*   ...y asÝ sucesivamente.

Observamos que el ßrbol se ramifica de forma similar a la propia secuencia de Fibonacci.  Cada nodo representa una llamada a la funci¾n `Fibonacci`. La altura del ßrbol es aproximadamente `n` (ya que en cada rama, se reduce el valor de `n` hasta llegar al caso base).

El n·mero de nodos en el ßrbol crece exponencialmente.  En el peor de los casos, el ßrbol estarß "completo" hasta una altura cercana a `n`.  Una cota inferior del n·mero de nodos es de orden F(n), siendo F(n) el n-Úsimo n·mero de Fibonacci, el cual es aproximadamente `((1+sqrt(5))/2)^n`, lo que indica un crecimiento exponencial.

**4. Conclusi¾n Final: Complejidad**

*   **Peor Caso (O):**  O(2<sup>n</sup>).  Aunque el n·mero preciso de nodos es un poco menor que 2<sup>n</sup> (debido a que el ßrbol no es estrictamente binario, es un ßrbol k-ario con k cercano a 2), la complejidad sigue siendo exponencial. Una derivaci¾n mßs precisa demuestra que la complejidad es O( ( (1+sqrt(5))/2 )<sup>n</sup> ) que se simplifica a O(1.618<sup>n</sup>), que es, sin embargo, exponencial.  La clave aquÝ es reconocer el crecimiento exponencial basado en la estructura del ßrbol.
*   **Mejor Caso (?):** ?(1).  Esto ocurre cuando la entrada `n` es 0 o 1, donde la funci¾n retorna inmediatamente.
*   **Caso Promedio (?):** ?(2<sup>n</sup>). El caso promedio sigue siendo exponencial ya que, en la gran mayorÝa de las ejecuciones, el ßrbol de recursi¾n se expande significativamente.

**En resumen:**

El algoritmo recursivo para calcular el Fibonacci tiene una complejidad exponencial, lo que lo hace muy ineficiente para valores grandes de `n`. Es un buen ejemplo de un algoritmo donde la recursi¾n sin memoizaci¾n conduce a una complejidad computacional prohibitiva. Una implementaci¾n iterativa o una recursi¾n con memoizaci¾n reducirÝa la complejidad a O(n).

--- 4. Generando Trace Table ---

Anßlisis finalizado.
